/*
 * Midterm_121044029_Mehmet_Gurol_Cay
 *
 * seeWhat.c
 * -------
 * Created on 09/04/2016 by Mehmet Gurol Cay
 *
 * Description
 * -----------
 * 		The seeWhat program performs shiftedReverse and 2D Convolution
 *      operations on a 2n * 2n matrix randomly generated by the timerServer
 *      program. This saves the results of the operation in the
 *      sw_ # n_ # pid_log.txt file for each matrix received.
 *
 *      The shiftedReverse operation is the calculation of the determinant of
 *      the matrix obtained by taking the inverse of the n*n parts of
 *      the 2n*2n matrix and replacing it.
 *
 *
 */
//#define DEBUG
#include "seeWhat.h"

int main(int argc, char const *argv[]){
    int mainFifoFD;

    if (argc != 2) {
        fprintf(stderr, "Usage: %s <mainFifoName>\n",argv[0]);
        return 1;
    }

    if (signal(SIGINT, SIGINT_handler) == SIG_ERR){
        perror("SIGINT install error");
        return 1;
    }

    mainFifoName = (char *)calloc(strlen(argv[1]),sizeof(char));
    strcat(mainFifoName,argv[1]);

    requestToServer();

    return 0;

}
void requestToServer(){
    int clientFifoFD;
    int childPID;
    int i = 0, j = 0;
    int requestCounter = 0;
    memset(clientInf.clientFifoName,32,sizeof(char));

    clientInf.clientPID = (int)getpid();
    snprintf(clientInf.clientFifoName,32,"%ld.fifo",(long)getpid());

    #ifdef DEBUG
    fprintf(stderr, "DEBUG****clientFifoName: %s\n",clientInf.clientFifoName);
    #endif

    if ((mkfifo(clientInf.clientFifoName,FIFO_PERMS) == -1) && (errno != EEXIST)) {
        fprintf(stderr, "Server failed to create the %s:%s\n",clientInf.clientFifoName,strerror(errno) );
        exit(EXIT_FAILURE);
    }

    if ((mainFifoFD = open(mainFifoName,O_RDWR)) == ERROR) {
        fprintf(stderr, "Server failed to open its %s: %s\n",mainFifoName, strerror(errno));
        exit(EXIT_FAILURE);
    }

    //write client fifo name from main fifo
    if( write(mainFifoFD,&clientInf,sizeof(clientInf)) == ERROR){
        fprintf(stderr, "Failed to write client information %s\n",strerror(errno) );
        exit(EXIT_FAILURE);
    }

    if ((clientFifoFD = open(clientInf.clientFifoName,O_RDONLY)) == ERROR) {
        perror("Failed to open client fifo");
        exit(EXIT_FAILURE);
    }

    //serverPID was read from client fifo
    if(ERROR == r_read(clientFifoFD,&serverInf,sizeof(serverInf))){
        perror("Failed to read from client fifo");
        exit(EXIT_FAILURE);
    }

    sRev2DCov.shiftedRevMatrix = allocMatrix(serverInf.matrixSize);
    sRev2DCov.twoDConvMatrix = allocMatrix(serverInf.matrixSize);
    // Signal to connect to child server
    if ((kill(serverInf.serverPID,SIGUSR1)) == ERROR) {
        perror("Failed to send signal to server");
        kill(getpid(),SIGINT);
    }

    if (ERROR == r_read(clientFifoFD,&subServerInf,sizeof(subServerInf))) {
        perror("Failed to read from client fifo");
        exit(EXIT_FAILURE);
    }

    #ifdef DEBUG
    fprintf(stderr, "DEBUG****subServerPID: %d\n",subServerInf.subServerPID );
    #endif

    snprintf(shiftedReverseTxt,32,"%d_%s",(int)getpid(),SHIFTEDREV_FILE);
    snprintf(convolutionTxt,32,"%d_%s",(int)getpid(),TWODCONV_FILE);
    resultOfMatrices.clientPID = (int)getpid();

    while(1){
        // Signal to request matrix from child server

        if ((kill(subServerInf.subServerPID,SIGUSR2)) == ERROR) {
            perror("Failed to send signal to subserver");
            resultOfMatrices.isKill = true;
            sendDatasToShowResult();
            break;
        }
        if (!readMatrixInf(clientFifoFD)) {
            resultOfMatrices.isKill = true;
            sendDatasToShowResult();
            break;
        }

        ++requestCounter;

        for (i = 0; i < 2; i++) {
            if ((childPID = fork()) <= 0 )
                break;
        }

        if (childPID == 0) {
            if (i == 0) {
                shiftedReverse();
                exit(EXIT_SUCCESS);
            } else if( i == 1){
                twoDConvolution();
                exit(EXIT_SUCCESS);
            }
        } else if (childPID == ERROR){
            perror("Failed to fork.");
            exit(EXIT_FAILURE);
        } else {
            while(wait(NULL) != ERROR);

            readFromFile();

            memset(logFileName,'\0',sizeof(char));

            snprintf(logFileName,32,"./log/%s_%d%s",SEEWHAT_LOG_FILE,requestCounter,LOG_EXTESION);

            if ((pClientLog = fopen(logFileName,"w")) == NULL) {
                perror("Failed to opened client log file");
                exit(EXIT_FAILURE);
            }

            writeToLogFile();
            resultOfMatrices.isKill = false;
            sendDatasToShowResult();

            fclose(pClientLog);
        }

        sleep(serverInf.timeMSec);
    }


    free(mainFifoName);
    close(mainFifoFD);
    close(clientFifoFD);
    unlink(clientInf.clientFifoName);
    unlink(shiftedReverseTxt);
    unlink(convolutionTxt);
    freeMatrix(sRev2DCov.shiftedRevMatrix,serverInf.matrixSize);
    freeMatrix(sRev2DCov.twoDConvMatrix,serverInf.matrixSize);
    //freeMatrix(subServerInf.matrix,serverInf.matrixSize);

}
void sendDatasToShowResult(){
    resultOfMatrices.orgDet = subServerInf.det;
    int showResultFifoFD,i;
    int counter = 0;
    bool flag = true;
    #ifdef DEBUG
    fprintf(stderr, "DEBUG****sendDatasToShowResult**************************\n" );
    #endif
    while(1){
        if ((showResultFifoFD = open(SHOWRESULTS_FIFO,O_RDWR)) == ERROR) {
            fprintf(stderr, "showResults failed to open its %s: %s\n",SHOWRESULTS_FIFO, strerror(errno));
            sleep(1);
            ++counter;
        } else {
            flag = true;
            break;
        }
        if (counter == 10 ) {
            break;
        }
    }

    if (flag == true) {
        if( write(showResultFifoFD,&resultOfMatrices,sizeof(resultOfMatrices)) == ERROR){
            fprintf(stderr, "Failed to write seeWhat information %s\n",strerror(errno) );
            exit(EXIT_FAILURE);
        }
        close(showResultFifoFD);
    }
}

void generateKernel(){
    kernelMatrix[0][0] = -1;
    kernelMatrix[0][1] = -1;
    kernelMatrix[0][2] = -1;
    kernelMatrix[1][0] = -2;
    kernelMatrix[1][1] = 10;
    kernelMatrix[1][2] = -2;
    kernelMatrix[2][0] = -1;
    kernelMatrix[2][1] = -1;
    kernelMatrix[2][2] = -1;
}

void readFromFile(){
    FILE *inputFile;
    int i,j;

    if ( (inputFile = fopen(shiftedReverseTxt,"r")) == NULL ){
        perror("File was not opened");
        exit(EXIT_FAILURE);
    }

    for (i = 0; i < serverInf.matrixSize; i++) {
        for (j = 0; j < serverInf.matrixSize; j++) {
            fscanf(inputFile, "%lf",&sRev2DCov.shiftedRevMatrix[i][j] );
        }
    }
    fscanf(inputFile, "%lf",&resultOfMatrices.detShifted );
    fscanf(inputFile, "%d",&resultOfMatrices.calcTimeOfShifted );

    #ifdef DEBUG
    fprintf(stderr, "DEBUG****Shifted Reverse Matrix PARENT!:\n");

    for (i = 0; i < serverInf.matrixSize; i++) {
        for (j = 0; j < serverInf.matrixSize; j++) {
            fprintf(stderr, "%.3f  ",sRev2DCov.shiftedRevMatrix[i][j] );
        }
        fprintf(stderr, "\n" );
    }
    fprintf(stderr, "detShifted:%.3f\n",resultOfMatrices.detShifted );
    fprintf(stderr, "calcTimeOfShifted: %d\n",resultOfMatrices.calcTimeOfShifted );
    #endif


    if ((inputFile = fopen(convolutionTxt,"r")) == NULL) {
        perror("File was not opened");
        exit(EXIT_FAILURE);
    }


    for (i = 0; i < serverInf.matrixSize; i++) {
        for (j = 0; j < serverInf.matrixSize; j++) {
            fscanf(inputFile, "%lf",&sRev2DCov.twoDConvMatrix[i][j] );
        }
    }
    fscanf(inputFile, "%lf",&resultOfMatrices.detConvolution );
    fscanf(inputFile, "%d",&resultOfMatrices.calcTimeOfConv );

    #ifdef DEBUG
    fprintf(stderr, "DEBUG****Convolution matrix PARENT!:\n");

    for (i = 0; i < serverInf.matrixSize; i++) {
        for (j = 0; j < serverInf.matrixSize; j++) {
            fprintf(stderr, "%.3f  ",sRev2DCov.twoDConvMatrix[i][j] );
        }
        fprintf(stderr, "\n" );
    }
    fprintf(stderr, "detConvolution:%.3f\n",resultOfMatrices.detConvolution );
    fprintf(stderr, "calcTimeOfConv: %d\n",resultOfMatrices.calcTimeOfConv );

    #endif

    fclose(inputFile);
}


void writeToLogFile(){
    int i = 0, j = 0;
    fprintf(pClientLog, "org = [" );
    for (i = 0; i < serverInf.matrixSize; i++) {
        for (j = 0; j < serverInf.matrixSize; j++) {
            fprintf(pClientLog, "%.3f  ",subServerInf.matrix[i][j] );
        }
        if (i == serverInf.matrixSize -1)
            fprintf(pClientLog, "]\n\n" );
        else
            fprintf(pClientLog, "\n");
    }

    fprintf(pClientLog, "shifted = [");
    for (i = 0; i < serverInf.matrixSize; i++) {
        for (j = 0; j < serverInf.matrixSize; j++) {
            fprintf(pClientLog, "%.3f  ",sRev2DCov.shiftedRevMatrix[i][j] );
        }
        if (i == serverInf.matrixSize -1)
            fprintf(pClientLog, "]\n\n" );
        else
            fprintf(pClientLog, "\n");
    }

    fprintf(pClientLog, "convolution = [" );
    for (i = 0; i < serverInf.matrixSize; i++) {
        for (j = 0; j < serverInf.matrixSize; j++) {
            fprintf(pClientLog, "%.3f  ",sRev2DCov.twoDConvMatrix[i][j] );
        }
        if (i == serverInf.matrixSize -1)
            fprintf(pClientLog, "]\n\n" );
        else
            fprintf(pClientLog, "\n");
    }

}

bool readMatrixInf(int clientFifoFD){
    int i,j;
    if (ERROR == r_read(clientFifoFD,&subServerInf,sizeof(subServerInf))) {
        perror("Failed to read from client fifo");
        exit(EXIT_FAILURE);
    }

    #ifdef DEBUG
    fprintf(stderr, "DEBUG****okudum matrixSize: %d\n",serverInf.matrixSize );
    fprintf(stderr, "DEBUG****sizeof struct: %ld\n",sizeof(subServerInf) );
    fprintf(stderr, "DEBUG****The receiving matrix:\n" );

    for (i = 0; i < serverInf.matrixSize; i++) {
        for (j = 0; j < serverInf.matrixSize; j++) {
            fprintf(stderr, "%.02f ",subServerInf.matrix[i][j]);
        }
        fprintf(stderr, "\n");
    }
    #endif

    if (subServerInf.isKill) {
        return false;
    }
    return true;
}

void freeMatrix(double **mat, int size){
    int i = 0;

    for (i = 0; i < size; i++)
        free(mat[i]);
    free(mat);
}

double **allocMatrix(int size){
    int i = 0;
    double **matrix;

    matrix = (double **)calloc(size,sizeof(double *));
    for (i = 0; i < size; i++) {
        matrix[i] = (double *)calloc(size,sizeof(double));
    }

    return matrix;
}

void shiftedReverse(){
    struct timespec inputTime;
    struct timespec calculatedTime;
    double **unitMatrix;
    double **tempMatrix;
    FILE *pShiftedRevFile;
    int i,j;
    double det;
    long timedif;

    if (clock_gettime(CLOCK_REALTIME,&inputTime)){
        perror("Failed to get first time");
        return;
    }

    if(!areInvertibleSubMatrix()){
        fprintf(stderr, "Sub matrix are not invertible\n");
    }else {
        tempMatrix = allocMatrix(serverInf.matrixSize/2);

        unitMatrix = generateUnitMatrix(serverInf.matrixSize/2);
        copyMatrix(tempMatrix,0,0,serverInf.matrixSize/2);
        invertSubMatrix(tempMatrix,unitMatrix,serverInf.matrixSize/2);
        copyShiftedRevMat(unitMatrix,0,0,serverInf.matrixSize/2);

        unitMatrix = generateUnitMatrix(serverInf.matrixSize/2);
        copyMatrix(tempMatrix,serverInf.matrixSize/2,0,serverInf.matrixSize);
        invertSubMatrix(tempMatrix,unitMatrix,serverInf.matrixSize/2);
        copyShiftedRevMat(unitMatrix,serverInf.matrixSize/2,0,serverInf.matrixSize);

        unitMatrix = generateUnitMatrix(serverInf.matrixSize/2);
        copyMatrix(tempMatrix,0,serverInf.matrixSize/2,serverInf.matrixSize);
        invertSubMatrix(tempMatrix,unitMatrix,serverInf.matrixSize/2);
        copyShiftedRevMat(unitMatrix,0,serverInf.matrixSize/2,serverInf.matrixSize);

        unitMatrix = generateUnitMatrix(serverInf.matrixSize/2);
        copyMatrix(tempMatrix,serverInf.matrixSize/2,serverInf.matrixSize/2,serverInf.matrixSize);
        invertSubMatrix(tempMatrix,unitMatrix,serverInf.matrixSize/2);
        copyShiftedRevMat(unitMatrix,serverInf.matrixSize/2,serverInf.matrixSize/2,serverInf.matrixSize);

        det = determinant(sRev2DCov.shiftedRevMatrix,serverInf.matrixSize);

        if (clock_gettime(CLOCK_REALTIME,&calculatedTime)){
            perror("Failed to get first time");
            return;
        }

        timedif = BILLION * (calculatedTime.tv_sec - inputTime.tv_sec) +
                    calculatedTime.tv_nsec - inputTime.tv_nsec;
        timedif = timedif / BILLION;

        #ifdef DEBUG
        fprintf(stderr, "DEBUG****timedif: %d\n",(int)timedif );
        #endif

        #ifdef DEBUG
        fprintf(stderr, "DEBUG****Shifted Reverse Matrix:\n");

        for (i = 0; i < serverInf.matrixSize; i++) {
            for (j = 0; j < serverInf.matrixSize; j++) {
                fprintf(stderr, "%.3f  ",sRev2DCov.shiftedRevMatrix[i][j] );
            }
            fprintf(stderr, "\n" );
        }
        #endif

        if ( (pShiftedRevFile = fopen(shiftedReverseTxt,"w")) == NULL){
            perror("Failed to open shiftedRev.txt file");
            exit(EXIT_FAILURE);
        }

        for (i = 0; i < serverInf.matrixSize; i++) {
            for (j = 0; j < serverInf.matrixSize; j++) {
                fprintf(pShiftedRevFile, "%.3f  ",sRev2DCov.shiftedRevMatrix[i][j] );
            }
            fprintf(pShiftedRevFile, "\n" );
        }
        fprintf(pShiftedRevFile, "%f\n",det );
        fprintf(pShiftedRevFile, "%d\n",(int)timedif );

        fclose(pShiftedRevFile);
        freeMatrix(tempMatrix,serverInf.matrixSize/2);
        freeMatrix(unitMatrix,serverInf.matrixSize/2);
    }


}

//http://www.songho.ca/dsp/convolution/convolution.html
void twoDConvolution(){
    struct timespec inputTime;
    struct timespec calculatedTime;
    int i,j,m,mm,n,nn,ii,jj;
    int kCols = 3, kRows = 3;
    long timedif;
    double det;
    FILE *pConvolutionFile;

    if (clock_gettime(CLOCK_REALTIME,&inputTime)){
        perror("Failed to get first time");
        return;
    }

    generateKernel();

    // find center position of kernel (half of kernel size)
    int kCenterX = kCols / 2;
    int kCenterY = kRows / 2;

    for(i = 0; i < serverInf.matrixSize; ++i)              // rows
    {
        for(j = 0; j < serverInf.matrixSize; ++j)          // columns
        {
            for(m = 0; m < kRows; ++m)     // kernel rows
            {
                mm = kRows - 1 - m;      // row index of flipped kernel

                for(n = 0; n < kCols; ++n) // kernel columns
                {
                    nn = kCols - 1 - n;  // column index of flipped kernel

                    // index of input signal, used for checking boundary
                    ii = i + (m - kCenterY);
                    jj = j + (n - kCenterX);

                    // ignore input samples which are out of bound
                    if( ii >= 0 && ii < serverInf.matrixSize && jj >= 0 && jj < serverInf.matrixSize )
                        sRev2DCov.twoDConvMatrix[i][j] += subServerInf.matrix[ii][jj] * kernelMatrix[mm][nn];
                }
            }
        }
    }

    det = determinant(sRev2DCov.shiftedRevMatrix,serverInf.matrixSize);

    if (clock_gettime(CLOCK_REALTIME,&calculatedTime)){
        perror("Failed to get first time");
        return;
    }

    timedif = BILLION * (calculatedTime.tv_sec - inputTime.tv_sec) +
                calculatedTime.tv_nsec - inputTime.tv_nsec;
    timedif = timedif / BILLION;

    #ifdef DEBUG
    fprintf(stderr, "DEBUG****Convolution matrix: \n");
    for (i = 0; i < serverInf.matrixSize; i++) {
        for (j = 0; j < serverInf.matrixSize; j++) {
            fprintf(stderr, "%.3f  ",sRev2DCov.twoDConvMatrix[i][j] );
        }
        fprintf(stderr, "\n" );
    }
    #endif

    if ((pConvolutionFile = fopen(convolutionTxt,"w")) == NULL) {
        perror("Failed to open twodConv.txt file");
        exit(EXIT_FAILURE);
    }

    for (i = 0; i < serverInf.matrixSize; i++) {
        for (j = 0; j < serverInf.matrixSize; j++) {
            fprintf(pConvolutionFile, "%.3f  ",sRev2DCov.twoDConvMatrix[i][j] );
        }
        fprintf(pConvolutionFile, "\n" );
    }
    fprintf(pConvolutionFile, "%f\n",det );
    fprintf(pConvolutionFile, "%d\n",(int)timedif );
    fclose(pConvolutionFile);
}

void copyShiftedRevMat(double **source,int startCIndex,int startRIndex, int size){
    int i,j,m,k;
    for (i = startCIndex , m = 0; i < size && m < serverInf.matrixSize/2; i++,m++) {
        for (j = startRIndex, k = 0; j < size  && k < serverInf.matrixSize/2; j++,k++) {
            sRev2DCov.shiftedRevMatrix[i][j] = source[m][k];
        }
    }
}


void invertSubMatrix(double **tempMatrix,double **unitMatrix,int sizeOfMatrix){
    int i,j,m;
    double d,k;

    #ifdef DEBUG
    fprintf(stderr, "DEBUG****subMatrix: tempMatrix :\n");
    for (i = 0; i < sizeOfMatrix; i++) {
        for (j = 0; j < sizeOfMatrix; j++) {
            fprintf(stderr, "%.3f  ",tempMatrix[i][j] );
        }
        fprintf(stderr, "\n" );
    }
    #endif

    for (i = 0; i < sizeOfMatrix; i++) {
        d = tempMatrix[i][i];
        for ( j = 0; j < sizeOfMatrix; j++) {
            tempMatrix[i][j] = tempMatrix[i][j]/d;
            unitMatrix[i][j] = unitMatrix[i][j]/d;
        }
        for (m = 0; m < sizeOfMatrix; m++) {
            if (m != i) {
                k = tempMatrix[m][i];
                for (j = 0; j < sizeOfMatrix; j++) {
                    tempMatrix[m][j] = tempMatrix[m][j] - (tempMatrix[i][j]*k);
                    unitMatrix[m][j] = unitMatrix[m][j] - (unitMatrix[i][j]*k);
                }
            }
        }
    }
    #ifdef DEBUG
    fprintf(stderr, "DEBUG****invert:\n");
    for (i = 0; i < sizeOfMatrix; i++) {
        for (j = 0; j < sizeOfMatrix; j++) {
            fprintf(stderr, "%.3f  ",unitMatrix[i][j] );
        }
        fprintf(stderr, "\n" );
    }
    #endif

}

//http://study-for-exam.blogspot.com.tr/2013/04/write-c-progrm-to-find-determinant-of.html
double determinant(double **mtrx,int size)
{
    int i = 0, k = 0,m = 0;
    double det = 0.0;
    double **temp;

    if (size == 2) {
        return mtrx[0][0] * mtrx[1][1] - mtrx[0][1] * mtrx[1][0];
    } else {
        temp = allocMatrix(size-1);
        for (i = 0; i < size; i++) {
            for ( k = 1; k < size; k++) {
                for (m = 0; m < size; m++) {
                    if (m < i) {
                        temp[k - 1][m] = subServerInf.matrix[k][m];
                    } else if (m > i) {
                        temp[k - 1][m - 1] = subServerInf.matrix[k][m];
                    }
                }
            }
            det += mtrx[0][i] * pow(-1,i) * determinant(temp,size - 1);
        }
        freeMatrix(temp,size-1);
        return det;
    }
}

bool areInvertibleSubMatrix(){
	int i = 0, j = 0;
	double det;
    double **tempMatrix;
    bool flag= false;
    tempMatrix = allocMatrix(serverInf.matrixSize/2);

    copyMatrix(tempMatrix,0,0,serverInf.matrixSize/2);
    det = determinant(tempMatrix,serverInf.matrixSize/2);
    if (det != 0.0000) {
        copyMatrix(tempMatrix,serverInf.matrixSize/2,0,serverInf.matrixSize);
        det = determinant(tempMatrix,serverInf.matrixSize/2);
        if (det != 0.0000) {
            copyMatrix(tempMatrix,0,serverInf.matrixSize/2,serverInf.matrixSize);
            det = determinant(tempMatrix,serverInf.matrixSize/2);
            if (det != 0.0000) {
                copyMatrix(tempMatrix,serverInf.matrixSize/2,serverInf.matrixSize/2,serverInf.matrixSize);
                det = determinant(tempMatrix,serverInf.matrixSize/2);
                if (det != 0.0000) {
                    flag = true;
                }
            }
        }
    }
    return flag;
}

void copyMatrix(double **destMtrx,int startCIndex, int startRIndex, int size){
    int i = 0, j = 0,k = 0,m = 0;

    for (i = startCIndex, k = 0; i < size && k < serverInf.matrixSize/2; i++,k++) {
        for (j = startRIndex, m = 0; j < size && m < serverInf.matrixSize/2; j++,m++) {
            destMtrx[k][m] = subServerInf.matrix[i][j];
        }
    }


}

double **generateUnitMatrix(int matrixSize){
    int i = 0, j = 0;
    double **unitMatrix;

    unitMatrix = allocMatrix(matrixSize);

    for (i = 0; i < matrixSize; i++) {
        for (j = 0; j < matrixSize; j++) {
            if(i == j)
                unitMatrix[i][j] = 1;
            else
                unitMatrix[i][j] = 0;
        }
    }

    #ifdef DEBUG
    fprintf(stderr, "DEBUG****this is unit matrix: \n" );
    for (i = 0; i < matrixSize; i++) {
        for (j = 0; j < matrixSize; j++) {
            fprintf(stderr, "%.2f  ", unitMatrix[i][j]);
        }
        fprintf(stderr, "\n");
    }
    fprintf(stderr, "DEBUG****-------\n" );
    #endif

    return unitMatrix;
}

void SIGINT_handler(int signum){
    fprintf(stderr, "\nCaught signal %d, coming out...",signum );
    free(mainFifoName);
    close(mainFifoFD);
    unlink(clientInf.clientFifoName);
    unlink(shiftedReverseTxt);
    unlink(convolutionTxt);
    freeMatrix(sRev2DCov.shiftedRevMatrix,serverInf.matrixSize);
    freeMatrix(sRev2DCov.twoDConvMatrix,serverInf.matrixSize);

    if ((kill(subServerInf.subServerPID,SIGINT)) == ERROR) {
        perror("Failed to send signal to subserver");
        exit(EXIT_FAILURE);
    }
    exit(EXIT_SUCCESS);
}

ssize_t r_read(int fd, void *buf, size_t size) {
	ssize_t retval;
	while (retval = read(fd, buf, size), retval == -1 && errno == EINTR) ;

	return retval;
}
